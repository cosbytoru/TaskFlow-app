[,]$  tail -n 3 TPC_M_0291_20250822_01.csv > ./test.csv
[,]$ ./mask_csv.sh -K 8,9,10,11,12,13 ./test.csv > ./masked_data.csv
[,]$
[,]$ cat masked_data.csv
,"2649",,,"DATA",,,"********",,,"****",,,"0008",,,"000131091",,,"99000",,,"鈴木　まゆこ",,,
,"2650",,,"DATA",,,"********",,,"****",,,"0854",,,"000146272",,,"99000",,,"鈴木　まゆこ",,,
,"2651",,,"END",,,"****",
[,]$ tail -n 3 TPC_M_0291_20250822_01.csv
"2649","DATA","TTT03328","4000","0008","000131091","99000","鈴木　まゆこ"
"2650","DATA","TTT03328","4001","0854","000146272","99000","鈴木　まゆこ"
"2651","END","2652"
#!/bin/bash

#================================================================
# CSVマスク化ツール
#
# 説明:
#   CSVファイル内の指定されたカラムをマスク化するツールです。
#   ダブルクォーテーションで囲まれたフィールドも正しく処理します。
#   (内部処理をPerlに変更し、文字コードの安定性を向上させました)
#
# 使用方法:
#   ./mask_csv.sh [options] [file1.csv ...]
#
# オプション:
#   -c <列番号> : マスクするカラム番号をカンマ区切りで指定 (例: '2,4')。
#   -d <列番号> : '19700101'でマスクする日付カラムをカンマ区切りで指定。
#   -K <列番号> : 【半角カナ用】全体を'*'でマスクするカラムをカンマ区切りで指定。
#   -r <文字列> : -cで指定した列の置換文字列 (デフォルト: "MASKED")。-k使用時は無効。
#   -k           : -cで指定した列にカスタムマスク処理(先頭1文字表示)を有効化。
#   -H <行数>   : マスク処理から除外するヘッダーの行数 (デフォルト: 0)。
#   -F <行数>   : マスク処理から除外するフッターの行数 (デフォルト: 0)。
#   -E <文字コード> : 入力ファイルの文字コードを指定 (例: SHIFT_JIS)。
#   -h           : このヘルプメッセージを表示する。
#
# 使用例:
#   # 2列目(半角カナ)を全体マスクし、4列目を日付マスクする
#   ./mask_csv.sh -K 2 -d 4 data.csv > masked_data.csv
#
#================================================================

# --- デフォルト設定 ---
REPLACEMENT_STRING="MASKED" # Perl側でクォート処理するため、ここでは不要
CUSTOM_MASK_ENABLED=false
MASK_COLS=""
DATE_MASK_COLS=""
HANKAKU_KANA_COLS=""
HEADER_LINES=0
FOOTER_LINES=0
ENCODING=""

# --- ヘルプメッセージ表示関数 ---
usage() {
    echo "使用方法: $0 [options] [file1.csv ...]"
    echo "  -c <列番号> : マスクするカラム番号をカンマ区切りで指定 (例: '2,4')。"
    echo "  -d <列番号> : '19700101'でマスクする日付カラムをカンマ区切りで指定。"
    echo "  -K <列番号> : 【半角カナ用】全体を'*'でマスクするカラムをカンマ区切りで指定。"
    echo "  -r <文字列> : -cで指定した列の置換文字列 (デフォルト: \"MASKED\")。-k使用時は無効。"
    echo "  -k           : -cで指定した列にカスタムマスク処理(先頭1文字表示)を有効化。"
    echo "  -H <行数>   : マスク処理から除外するヘッダーの行数 (デフォルト: 0)。"
    echo "  -F <行数>   : マスク処理から除外するフッターの行数 (デフォルト: 0)。"
    echo "  -E <文字コード> : 入力ファイルの文字コードを指定 (例: SHIFT_JIS)。"
    echo "  -h           : このヘルプメッセージを表示する。"
    exit 1
}

# --- オプション解析 ---
while getopts "c:d:K:r:kH:F:E:h" opt; do
    case ${opt} in
        c)
            MASK_COLS=${OPTARG}
            ;;
        d)
            DATE_MASK_COLS=${OPTARG}
            ;;
        K)
            HANKAKU_KANA_COLS=${OPTARG}
            ;;
        r)
            REPLACEMENT_STRING=${OPTARG}
            ;;
        k)
            CUSTOM_MASK_ENABLED=true
            ;;
        H)
            HEADER_LINES=${OPTARG}
            ;;
        F)
            FOOTER_LINES=${OPTARG}
            ;;
        E)
            ENCODING=${OPTARG}
            ;;
        h)
            usage
            ;;
        \?)
            usage
            ;;
    esac
done
shift $((OPTIND - 1))

# --- 必須引数の検証 ---
if [ -z "${MASK_COLS}" ] && [ -z "${DATE_MASK_COLS}" ] && [ -z "${HANKAKU_KANA_COLS}" ]; then
    echo "エラー: -c, -d, -K のいずれかを指定する必要があります。-hでヘルプを表示します。" >&2
    exit 1
fi

if [ $# -eq 0 ]; then
    echo "エラー: 処理対象のファイルが指定されていません。-hでヘルプを表示します。" >&2
    exit 1
fi

# --- Perlスクリプトをヒアドキュメントで変数に格納 ---
read -r -d '' PERL_SCRIPT << 'EOF'
use strict;
use warnings;
use utf8;
binmode(STDIN, ":utf8");
binmode(STDOUT, ":utf8");

# --- 設定値の読み込み ---
my $cols = $ENV{'MASK_COLS'};
my $date_cols = $ENV{'DATE_MASK_COLS'};
my $hankaku_cols = $ENV{'HANKAKU_KANA_COLS'};
my $replacement = $ENV{'REPLACEMENT_STRING'};
my $custom_mask_enabled = $ENV{'CUSTOM_MASK_ENABLED'};
my $header_lines = $ENV{'HEADER_LINES'};
my $footer_lines = $ENV{'FOOTER_LINES'};
my $total_lines = $ENV{'TOTAL_LINES'};

# --- マスク対象カラムをハッシュに格納 ---
my %mask_targets;
if ($cols) {
    for my $col (split /,/, $cols) { $mask_targets{$col} = 1; }
}
my %date_mask_targets;
if ($date_cols) {
    for my $col (split /,/, $date_cols) { $date_mask_targets{$col} = 1; }
}
my %hankaku_kana_targets;
if ($hankaku_cols) {
    for my $col (split /,/, $hankaku_cols) { $hankaku_kana_targets{$col} = 1; }
}

my $epoch_date = '19700101';

# --- メイン処理 ---
while (<>) {
    chomp;
    my $line = $_;

    # ヘッダー/フッター行はそのまま出力
    if ($. <= $header_lines or ($total_lines > 0 and ($total_lines - $.) < $footer_lines)) {
        print "$line\n";
        next;
    }

    # FPATのPerl版正規表現でフィールドを抽出
    my @fields = $line =~ m/([^,"]*|"[^"]*")/g;
    my @new_fields;

    for my $i (0 .. $#fields) {
        my $col_num = $i + 1;
        my $field = $fields[$i];
        my $is_quoted = ($field =~ s/^"|"//g);
        my $content = $field;

        if (length($content) > 0) {
            # 優先順位: 日付 -> 半角カナ -> 通常マスク
            if (exists $date_mask_targets{$col_num}) {
                $content = $epoch_date;
            }
            elsif (exists $hankaku_kana_targets{$col_num}) {
                $content = '*' x length($content);
            }
            elsif (exists $mask_targets{$col_num}) {
                if ($custom_mask_enabled) {
                    my $first_char = substr($content, 0, 1);
                    my $rest = substr($content, 1);
                    $rest =~ s/(\d)/0/g;
                    $rest =~ s/([^\x00-\x7F])/＊/g; # 全角
                    $rest =~ s/([^\d＊])/ /g; # 数字と全角以外
                    $rest =~ s/ / /g; # 半角アスタリスク
                    $content = $first_char . $rest;
                } else {
                    $content = $replacement;
                }
            }
        }
        
        # クォートを戻す
        $field = $is_quoted ? '"' . $content . '"' : $content;
        push @new_fields, $field;
    }

    print join(',', @new_fields) . "\n";
}
EOF

# --- メイン処理ループ ---
for file in "$@"; do
    if [ ! -f "$file" ]; then
        echo "警告: ファイルが見つかりません。スキップします: $file" >&2
        continue
    fi
    
    export MASK_COLS HANKAKU_KANA_COLS DATE_MASK_COLS REPLACEMENT_STRING CUSTOM_MASK_ENABLED HEADER_LINES FOOTER_LINES
    
    TOTAL_LINES=0
    if [ "${FOOTER_LINES}" -gt 0 ]; then
        if [ -n "${ENCODING}" ]; then
            TOTAL_LINES=$(iconv -f "${ENCODING}" -t UTF-8 -- "$file" | wc -l)
        else
            TOTAL_LINES=$(wc -l < "$file")
        fi
    fi
    export TOTAL_LINES

    if [ -n "${ENCODING}" ]; then
        if ! command -v iconv &> /dev/null; then
            echo "エラー: iconvコマンドが見つかりません。-Eオプションは使用できません。" >&2
            exit 1
        fi
        iconv -f "${ENCODING}" -t UTF-8 -- "$file" | perl -e "$PERL_SCRIPT"
    else
        perl -e "$PERL_SCRIPT" < "$file"
    fi
done
