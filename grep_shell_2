suzuki_test]$ head -n 1 509_1_CustomerMaster_All_20250916.csv | od -c
0000000   "   0   "   ,   "   T   O   P   "   ,   "   2   3   2   "   ,
0000020   "   2   0   2   5   0   9   1   6   "   ,   "   0   "   ,   "
0000040   0   0   0   0   0   "   ,   "   0   0   0   "   ,   "   0   0
0000060   0   "   ,   ,   ,   ,  \n
0000067


#!/bin/bash

#================================================================
# CSVフィルタリングツール (TOP/END, リストファイル, 複合CSV対応版)
#
# 説明:
#   指定された列の値が、指定された文字列(またはリストファイル)のいずれかと
#   一致するデータ行を抽出します。
#   ファイルの先頭にあるTOPレコードと末尾にあるENDレコードを自動的に処理し、
#   抽出後のデータに合わせて1列目のカウンタを再附番し、ENDレコードの
#   総レコード数を更新します。
#   空フィールドや、フィールド内にカンマを含むCSVレコードも正しく処理します。
#
# 依存関係:
#   gawk (GNU Awk) - CSVモード(PROCINFO["csv"])を使用するため
#
# 入力CSVの前提フォーマット:
#   "0","TOP",...
#   "1","DATA",...
#   ...
#   "N","END","N+1"
#
# 使用方法:
#   ./filter_csv.sh -c <列番号> {-s <文字列> | -f <リストファイル>} [file1.csv ...]
#
# オプション:
#   -c <列番号>        : フィルタリング対象のカラム番号。必須。
#   -s <文字列>        : 抽出する文字列をカンマ区切りで指定 (例: "G111,G3333")。
#   -f <リストファイル> : 抽出する文字列を1行1件で記述したファイル。
#   -h                 : このヘルプメッセージを表示する。
#
#================================================================

# --- デフォルト設定 ---
COLUMN=""
MATCH_STRINGS=""
LIST_FILE=""

# --- ヘルプメッセージ表示関数 ---
usage() {
    echo "使用方法: $0 -c <列番号> {-s <文字列> | -f <リストファイル>} [file1.csv ...]"
    echo "  -c <列番号>        : フィルタリング対象のカラム番号。必須。"
    echo "  -s <文字列>        : 抽出する文字列をカンマ区切りで指定 (例: \"G111,G3333\")。"
    echo "  -f <リストファイル> : 抽出する文字列を1行1件で記述したファイル。"
    echo "  -h                 : このヘルプメッセージを表示する。"
    exit 1
}

# --- オプション解析 ---
while getopts "c:s:f:h" opt; do
    case ${opt} in
        c)
            COLUMN=${OPTARG}
            ;;
        s)
            MATCH_STRINGS=${OPTARG}
            ;;
        f)
            LIST_FILE=${OPTARG}
            ;;
        h)
            usage
            ;;
        \?)
            usage
            ;;
    esac
done
shift $((OPTIND - 1))

# --- 必須引数の検証 ---
if [ -z "${COLUMN}" ]; then
    echo "エラー: -c は必須オプションです。" >&2
    usage
fi

if [ -n "${MATCH_STRINGS}" ] && [ -n "${LIST_FILE}" ]; then
    echo "エラー: -s と -f オプションは同時に指定できません。" >&2
    usage
fi

if [ -z "${MATCH_STRINGS}" ] && [ -z "${LIST_FILE}" ]; then
    echo "エラー: -s または -f のどちらか一方を指定してください。" >&2
    usage
fi

if [ -n "${LIST_FILE}" ] && [ ! -f "${LIST_FILE}" ]; then
    echo "エラー: リストファイルが見つかりません: ${LIST_FILE}" >&2
    exit 1
fi

if [ $# -eq 0 ]; then
    echo "エラー: 処理対象のファイルが指定されていません。" >&2
    usage
fi

# --- メイン処理ループ ---
for file in "$@"; do
    if [ ! -f "$file" ]; then
        echo "警告: ファイルが見つかりません。スキップします: $file" >&2
        continue
    fi

    if [ $(wc -l < "$file") -lt 2 ]; then
        echo "警告: ファイルの行数が2行未満です。スキップします: $file" >&2
        continue
    fi

    # awkを使用してCSVをフィルタリングおよび再構成
    awk -v col="${COLUMN}" \
        -v patterns="${MATCH_STRINGS}" \
        -v listfile="${LIST_FILE}" \
    '
    BEGIN {
        # gawkのCSVモードを有効にする (RFC 4180準拠)。これにより空フィールドも正しく扱える。
        PROCINFO["csv"] = 1
        OFS = ","

        # 抽出条件を match_targets 連想配列に格納する
        if (listfile != "") {
            while ((getline line < listfile) > 0) {
                # 行の前後の空白を削除
                gsub(/^[ \t]+|[ \t]+$/, "", line)
                # 空行はスキップ
                if (line == "") continue
                match_targets[line] = 1
            }
            close(listfile)
        }
        else if (patterns != "") {
            split(patterns, pattern_array, ",")
            for (p in pattern_array) {
                match_targets[pattern_array[p]] = 1
            }
        }
    }

    # 全ての行を配列に格納
    { lines[FNR] = $0 }

    END {
        # --- TOP/ENDレコードの形式を検証 ---
        # $0に代入することで、gawkにCSVとしてパースさせる
        $0 = lines[1]
        if ($2 != "TOP") {
            print "エラー: 1行目がTOPレコードではありません。ファイル:", FILENAME > "/dev/stderr"
            exit 1
        }
        $0 = lines[FNR]
        if ($2 != "END") {
            print "エラー: 最終行がENDレコードではありません。ファイル:", FILENAME > "/dev/stderr"
            exit 1
        }

        # 1. TOPレコードはそのまま出力
        print lines[1]

        # 2. データ行 (2行目から最終-1行目) をフィルタリング
        data_counter = 0
        if (FNR > 2) {
            for (i = 2; i < FNR; i++) {
                # gawkのCSVモードでパースするために$0にセットする
                $0 = lines[i]
                
                # CSVモードではフィールドのクォートは自動で除去されるため、$colはクォートなしの値になる
                field_to_check = $col

                # 抽出対象の文字列と一致するかチェック
                if (field_to_check in match_targets) {
                    data_counter++
                    
                    # 元の行のフォーマットを維持するため、パース前の行に対してカウンタ部分のみを置換
                    modified_line = lines[i]
                    sub(/^"[^"]*"/, "\"" data_counter "\"", modified_line)
                    print modified_line
                }
            }
        }

        # 3. 新しいENDレコードを生成して出力
        total_records = 1 + data_counter + 1
        end_counter = total_records - 1
        
        printf "\"%d\",\"END\",\"%d\"\n", end_counter, total_records
    }
    ' "$file"
done
