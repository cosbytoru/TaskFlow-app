#!/bin/bash

#================================================================
# CSVフィルタリングツール (TOP/ENDレコード対応版)
#
# 説明:
#   指定された列の値が、指定された文字列のいずれかと一致するデータ行を抽出します。
#   ファイルの先頭にあるTOPレコードと末尾にあるENDレコードを自動的に処理し、
#   抽出後のデータに合わせて1列目のカウンタを再附番し、ENDレコードの
#   総レコード数を更新します。
#
# 入力CSVの前提フォーマット:
#   "0","TOP",...
#   "1","DATA",...
#   ...
#   "N","END","N+1"
#
# 使用方法:
#   ./filter_csv.sh -c <列番号> -s <文字列> [file1.csv ...]
#
# オプション:
#   -c <列番号> : フィルタリング対象のカラム番号。必須。
#   -s <文字列> : 抽出する文字列をカンマ区切りで指定 (例: "G111,G3333")。必須。
#   -h          : このヘルプメッセージを表示する。
#
# 使用例:
#   # 3列目が "A01" または "B02" の行を抽出
#   ./filter_csv.sh -c 3 -s "A01,B02" data.csv
#
#================================================================

# --- デフォルト設定 ---
COLUMN=""
MATCH_STRINGS=""

# --- ヘルプメッセージ表示関数 ---
usage() {
    echo "使用方法: $0 -c <列番号> -s <文字列> [file1.csv ...]"
    echo "  -c <列番号> : フィルタリング対象のカラム番号。必須。"
    echo "  -s <文字列> : 抽出する文字列をカンマ区切りで指定 (例: \"G111,G3333\")。必須。"
    echo "  -h          : このヘルプメッセージを表示する。"
    exit 1
}

# --- オプション解析 ---
while getopts "c:s:h" opt; do
    case ${opt} in
        c)
            COLUMN=${OPTARG}
            ;;
        s)
            MATCH_STRINGS=${OPTARG}
            ;;
        h)
            usage
            ;;
        \?)
            usage
            ;;
    esac
done
shift $((OPTIND - 1))

# --- 必須引数の検証 ---
if [ -z "${COLUMN}" ] || [ -z "${MATCH_STRINGS}" ]; then
    echo "エラー: -c と -s は必須オプションです。-hでヘルプを表示します。" >&2
    exit 1
fi

if [ $# -eq 0 ]; then
    echo "エラー: 処理対象のファイルが指定されていません。-hでヘルプを表示します。" >&2
    exit 1
fi

# --- メイン処理ループ ---
for file in "$@"; do
    if [ ! -f "$file" ]; then
        echo "警告: ファイルが見つかりません。スキップします: $file" >&2
        continue
    fi

    # 行数が2行未満（TOP/ENDが揃わない）の場合はスキップ
    if [ $(wc -l < "$file") -lt 2 ]; then
        echo "警告: ファイルの行数が2行未満です。スキップします: $file" >&2
        continue
    fi

    # awkを使用してCSVをフィルタリングおよび再構成
    awk -v col="${COLUMN}" \
        -v patterns="${MATCH_STRINGS}" \
    '
    BEGIN {
        # FPATはフィールドのパターンを定義する。
        # 1. ダブルクォートで囲まれたフィールド: "[^"]*"
        # 2. クォートなしのフィールド (カンマ以外): [^,]+
        FPAT = "(\"[^\"]*\")|([^,]+)"
        OFS = ","

        # 抽出する文字列を連想配列に格納して高速参照
        split(patterns, pattern_array, ",")
        for (p in pattern_array) {
            match_targets[pattern_array[p]] = 1
        }
    }

    # 全ての行を配列に格納
    { lines[FNR] = $0 }

    END {
        # --- TOP/ENDレコードの形式を検証 ---
        $0 = lines[1]
        field2_top = $2
        gsub(/^"|"$/, "", field2_top)
        if (field2_top != "TOP") {
            print "エラー: 1行目がTOPレコードではありません。ファイル:", FILENAME > "/dev/stderr"
            exit 1
        }

        $0 = lines[FNR]
        field2_end = $2
        gsub(/^"|"$/, "", field2_end)
        if (field2_end != "END") {
            print "エラー: 最終行がENDレコードではありません。ファイル:", FILENAME > "/dev/stderr"
            exit 1
        }

        # 1. TOPレコードはそのまま出力
        print lines[1]

        # 2. データ行 (2行目から最終-1行目) をフィルタリング
        data_counter = 0
        if (FNR > 2) {
            for (i = 2; i < FNR; i++) {
                $0 = lines[i] # 行を再パース

                # 指定列の値を取得し、クォートを取り除く
                field_to_check = $col
                gsub(/^"|"$/, "", field_to_check)

                # 抽出対象の文字列と一致するかチェック
                if (field_to_check in match_targets) {
                    data_counter++
                    # 1列目のカウンタを再附番して出力
                    $1 = "\"" data_counter "\""
                    print # $0がOFSで再結合されて出力される
                }
            }
        }

        # 3. 新しいENDレコードを生成して出力
        total_records = 1 + data_counter + 1
        end_counter = total_records - 1
        
        # ユーザーの例 `”3”,"END","4"` に合わせて3フィールドでENDレコードを生成
        printf "\"%d\",\"END\",\"%d\"\n", end_counter, total_records
    }
    ' "$file"
done
