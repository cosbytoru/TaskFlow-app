#!/bin/bash

#================================================================
# CSVマスク化ツール
#
# 説明:
#   CSVファイル内の指定されたカラムをマスク化するツールです。
#   ダブルクォーテーションで囲まれたフィールドも正しく処理します。
#
# 使用方法:
#   ./mask_csv.sh [options] [file1.csv ...]
#
# オプション:
#   -c <列番号> : マスクするカラム番号をカンマ区切りで指定 (例: '2,4')。
#   -d <列番号> : '19700101'でマスクする日付カラムをカンマ区切りで指定。
#   -r <文字列> : -cで指定した列の置換文字列 (デフォルト: "MASKED")。-k使用時は無効。
#   -k           : -cで指定した列にカスタムマスク処理(先頭1文字表示、文字種/幅維持)を有効化。
#   -H           : ヘッダー行(1行目)をマスク処理の対象外にする。
#   -h           : このヘルプメッセージを表示する。
#
# 使用例:
#   # 2列目をカスタムルールで、4列目をEpoch日でマスクする
#   ./mask_csv.sh -c 2 -k -d 4 -H data.csv > masked_data.csv
#
#================================================================

# --- デフォルト設定 ---
REPLACEMENT_STRING="\"MASKED\"" # デフォルトの置換文字列 (CSV形式のためクォート付き)
MASK_HEADER=true
CUSTOM_MASK_ENABLED=false
MASK_COLS=""
DATE_MASK_COLS=""

# --- ヘルプメッセージ表示関数 ---
usage() {
    echo "使用方法: $0 [options] [file1.csv ...]"
    echo "  -c <列番号> : マスクするカラム番号をカンマ区切りで指定 (例: '2,4')。"
    echo "  -d <列番号> : '19700101'でマスクする日付カラムをカンマ区切りで指定。"
    echo "  -r <文字列> : -cで指定した列の置換文字列 (デフォルト: \"MASKED\")。-k使用時は無効。"
    echo "  -k           : -cで指定した列にカスタムマスク処理(先頭1文字表示、文字種/幅維持)を有効化。"
    echo "  -H           : ヘッダー行(1行目)をマスク処理の対象外にする。"
    echo "  -h           : このヘルプメッセージを表示する。"
    exit 1
}

# --- オプション解析 ---
while getopts "c:d:r:kHh" opt; do
    case ${opt} in
        c)
            MASK_COLS=${OPTARG}
            ;;
        d)
            DATE_MASK_COLS=${OPTARG}
            ;;
        r)
            # ユーザー指定の文字列をCSV形式のためダブルクォートで囲む
            REPLACEMENT_STRING="\"${OPTARG}\""
            ;;
        k)
            CUSTOM_MASK_ENABLED=true
            ;;
        H)
            MASK_HEADER=false
            ;;
        h)
            usage
            ;;
        \?)
            usage
            ;;
    esac
done
shift $((OPTIND - 1))

# --- 必須引数の検証 ---
if [ -z "${MASK_COLS}" ] && [ -z "${DATE_MASK_COLS}" ]; then
    echo "エラー: -c または -d のいずれかを指定する必要があります。-hでヘルプを表示します。" >&2
    exit 1
fi

if [ $# -eq 0 ]; then
    echo "エラー: 処理対象のファイルが指定されていません。-hでヘルプを表示します。" >&2
    exit 1
fi


# --- メイン処理ループ ---
for file in "$@"; do
    if [ ! -f "$file" ]; then
        echo "警告: ファイルが見つかりません。スキップします: $file" >&2
        continue
    fi

    # awkを使用してCSVを安定して処理
    awk -v cols="${MASK_COLS}" \
        -v date_cols="${DATE_MASK_COLS}" \
        -v replacement="${REPLACEMENT_STRING}" \
        -v mask_header="${MASK_HEADER}" \
        -v custom_mask_enabled="${CUSTOM_MASK_ENABLED}" \
    '
    # 高度なマスク処理を行うAWK関数:
    # - 最初の1文字を表示する
    # - 2文字目以降を以下のルールで置換する:
    #   - 数字は "0"
    #   - 全角文字(マルチバイト文字)は "＊"
    #   - その他の半角文字は "*"
    function custom_mask(str,    # local variables
                         result, first_char, i, char, masked_part) {
        if (length(str) <= 1) { return str; }
        first_char = substr(str, 1, 1);
        masked_part = "";
        for (i = 2; i <= length(str); i++) {
            char = substr(str, i, 1);
            if (char ~ /[0-9]/) { masked_part = masked_part "0"; }
            else if (char ~ /[^\x01-\x7E]/) { masked_part = masked_part "＊"; }
            else { masked_part = masked_part "*"; }
        }
        return first_char masked_part;
    }

    BEGIN {
        FPAT = "(\"[^\"]*\")|([^,]+)"
        OFS = ","
        EPOCH_DATE = "19700101"
        QUOTED_EPOCH_DATE = "\"" EPOCH_DATE "\""

        # マスク対象のカラムを高速に参照できるよう連想配列に格納
        if (cols != "") {
            split(cols, col_array, ",")
            for (i in col_array) { mask_targets[col_array[i]] = 1 }
        }
        if (date_cols != "") {
            split(date_cols, date_col_array, ",")
            for (i in date_col_array) { date_mask_targets[date_col_array[i]] = 1 }
        }
    }

    # 各行を処理
    {
        if (FNR == 1 && mask_header == "false") { print; next }

        for (i = 1; i <= NF; i++) {
            is_quoted = (substr($i, 1, 1) == "\"")

            # 日付のマスク処理を優先
            if (i in date_mask_targets) {
                $i = is_quoted ? QUOTED_EPOCH_DATE : EPOCH_DATE
            }
            # 次に通常のマスク処理
            else if (i in mask_targets) {
                if (custom_mask_enabled == "true") {
                    content_to_mask = is_quoted ? substr($i, 2, length($i) - 2) : $i
                    masked_content = custom_mask(content_to_mask)
                    $i = is_quoted ? "\"" masked_content "\"" : masked_content
                } else {
                    $i = replacement
                }
            }
        }
        print
    }
    ' "$file"
done

