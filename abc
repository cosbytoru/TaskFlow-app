#!/bin/bash

#================================================================
# CSVマスク化ツール
#
# 説明:
#   CSVファイル内の指定されたカラムをマスク化するツールです。
#   ダブルクォーテーションで囲まれたフィールドも正しく処理します。
#
# 使用方法:
#   ./mask_csv.sh [options] [file1.csv ...]
#
# オプション:
#   -c <列番号> : マスクするカラム番号をカンマ区切りで指定 (例: '2,4')。
#   -d <列番号> : '19700101'でマスクする日付カラムをカンマ区切りで指定。
#   -r <文字列> : -cで指定した列の置換文字列 (デフォルト: "MASKED")。-k使用時は無効。
#   -k           : -cで指定した列にカスタムマスク処理(先頭1文字表示、文字種/幅維持)を有効化。
#   -H <行数>   : マスク処理から除外するヘッダーの行数 (デフォルト: 0)。
#   -F <行数>   : マスク処理から除外するフッターの行数 (デフォルト: 0)。
#   -h           : このヘルプメッセージを表示する。
#
# 使用例:
#   # ヘッダー1行、フッター2行を除外し、2列目をカスタムルールで、4列目をEpoch日でマスク
#   ./mask_csv.sh -H 1 -F 2 -c 2 -k -d 4 data.csv > masked_data.csv
#
#================================================================

# --- デフォルト設定 ---
REPLACEMENT_STRING="\"MASKED\"" # デフォルトの置換文字列 (CSV形式のためクォート付き)
CUSTOM_MASK_ENABLED=false
MASK_COLS=""
DATE_MASK_COLS=""
HEADER_LINES=0
FOOTER_LINES=0

# --- ヘルプメッセージ表示関数 ---
usage() {
    echo "使用方法: $0 [options] [file1.csv ...]"
    echo "  -c <列番号> : マスクするカラム番号をカンマ区切りで指定 (例: '2,4')。"
    echo "  -d <列番号> : '19700101'でマスクする日付カラムをカンマ区切りで指定。"
    echo "  -r <文字列> : -cで指定した列の置換文字列 (デフォルト: \"MASKED\")。-k使用時は無効。"
    echo "  -k           : -cで指定した列にカスタムマスク処理(先頭1文字表示、文字種/幅維持)を有効化。"
    echo "  -H <行数>   : マスク処理から除外するヘッダーの行数 (デフォルト: 0)。"
    echo "  -F <行数>   : マスク処理から除外するフッターの行数 (デフォルト: 0)。"
    echo "  -h           : このヘルプメッセージを表示する。"
    exit 1
}

# --- オプション解析 ---
while getopts "c:d:r:kH:F:h" opt; do
    case ${opt} in
        c)
            MASK_COLS=${OPTARG}
            ;;
        d)
            DATE_MASK_COLS=${OPTARG}
            ;;
        r)
            # ユーザー指定の文字列をCSV形式のためダブルクォートで囲む
            REPLACEMENT_STRING="\"${OPTARG}\""
            ;;
        k)
            CUSTOM_MASK_ENABLED=true
            ;;
        H)
            HEADER_LINES=${OPTARG}
            ;;
        F)
            FOOTER_LINES=${OPTARG}
            ;;
        h)
            usage
            ;;
        \?)
            usage
            ;;
    esac
done
shift $((OPTIND - 1))

# --- 必須引数の検証 ---
if [ -z "${MASK_COLS}" ] && [ -z "${DATE_MASK_COLS}" ]; then
    echo "エラー: -c または -d のいずれかを指定する必要があります。-hでヘルプを表示します。" >&2
    exit 1
fi

if [ $# -eq 0 ]; then
    echo "エラー: 処理対象のファイルが指定されていません。-hでヘルプを表示します。" >&2
    exit 1
fi


# --- メイン処理ループ ---
for file in "$@"; do
    if [ ! -f "$file" ]; then
        echo "警告: ファイルが見つかりません。スキップします: $file" >&2
        continue
    fi
    
    TOTAL_LINES=$(wc -l < "$file")

    # awkを使用してCSVを安定して処理
    awk -v cols="${MASK_COLS}" \
        -v date_cols="${DATE_MASK_COLS}" \
        -v replacement="${REPLACEMENT_STRING}" \
        -v custom_mask_enabled="${CUSTOM_MASK_ENABLED}" \
        -v header_lines="${HEADER_LINES}" \
        -v footer_lines="${FOOTER_LINES}" \
        -v total_lines="${TOTAL_LINES}" \
    '
    # 高度なマスク処理を行うAWK関数:
    # - 最初の1文字を表示する
    # - 2文字目以降を以下のルールで置換する:
    #   - 数字は "0"
    #   - 全角文字(マルチバイト文字)は "＊"
    #   - その他の半角文字は "*"
    function custom_mask(str,    # local variables
                         result, first_char, i, char, masked_part) {
        if (length(str) <= 1) { return str; }
        first_char = substr(str, 1, 1);
        masked_part = "";
        for (i = 2; i <= length(str); i++) {
            char = substr(str, i, 1);
            if (char ~ /[0-9]/) { masked_part = masked_part "0"; }
            else if (char ~ /[^\x01-\x7E]/) { masked_part = masked_part "＊"; }
            else { masked_part = masked_part "*"; }
        }
        return first_char masked_part;
    }

    BEGIN {
        # FPATはフィールドのパターンを定義する。
        # 1. ダブルクォートで囲まれたフィールド: "[^"]*"
        # 2. クォートなしのフィールド (カンマ以外が0文字以上): [^,]*
        # [^,]+ から [^,]* に変更することで、空のフィールドを正しく認識する
        FPAT = "(\"[^\"]*\")|([^,]*)"
        OFS = ","
        EPOCH_DATE = "19700101"
        QUOTED_EPOCH_DATE = "\"" EPOCH_DATE "\""

        # マスク対象のカラムを高速に参照できるよう連想配列に格納
        if (cols != "") {
            split(cols, col_array, ",")
            for (i in col_array) { mask_targets[col_array[i]] = 1 }
        }
        if (date_cols != "") {
            split(date_cols, date_col_array, ",")
            for (i in date_col_array) { date_mask_targets[date_col_array[i]] = 1 }
        }
    }

    # 各行を処理
    {
        # ヘッダー行またはフッター行の場合は、何もせずにそのまま出力
        if (FNR <= header_lines || (total_lines - FNR) < footer_lines) {
            print $0
            next
        }

        # 日付のマスク処理を優先。指定された日付カラムをループ処理。
        for (col_num in date_mask_targets) {
            # この行にそのカラムが存在する場合のみ処理する
            if (col_num > 0 && col_num <= NF) {
                is_quoted = (substr($col_num, 1, 1) == "\"")
                $col_num = is_quoted ? QUOTED_EPOCH_DATE : EPOCH_DATE
            }
        }

        # 次に通常のマスク処理。指定された一般マスクカラムをループ処理。
        for (col_num in mask_targets) {
            # 日付として既にマスク済みの場合はスキップ
            if (col_num in date_mask_targets) {
                continue
            }
            # この行にそのカラムが存在する場合のみ処理する
            if (col_num > 0 && col_num <= NF) {
                if (custom_mask_enabled == "true") {
                    is_quoted = (substr($col_num, 1, 1) == "\"")
                    content_to_mask = is_quoted ? substr($col_num, 2, length($col_num) - 2) : $col_num
                    masked_content = custom_mask(content_to_mask)
                    $col_num = is_quoted ? "\"" masked_content "\"" : masked_content
                } else {
                    $col_num = replacement
                }
            }
        }
        print
    }
    ' "$file"
done

